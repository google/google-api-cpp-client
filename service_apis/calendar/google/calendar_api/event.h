// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// This code was generated by google-apis-code-generator 1.5.1

// ----------------------------------------------------------------------------
// NOTE: This file is generated from Google APIs Discovery Service.
// Service:
//   Calendar API (calendar/v3)
// Generated from:
//   Version: v3
//   Revision: 20171010
// Generated by:
//    Tool: google-apis-code-generator 1.5.1
//     C++: 0.1.5
#ifndef  GOOGLE_CALENDAR_API_EVENT_H_
#define  GOOGLE_CALENDAR_API_EVENT_H_

#include <string>
#include "googleapis/base/integral_types.h"
#include "googleapis/base/macros.h"
#include "googleapis/client/data/jsoncpp_data.h"
#include "googleapis/client/util/date_time.h"
#include "googleapis/strings/stringpiece.h"

#include "google/calendar_api/event_attachment.h"
#include "google/calendar_api/event_attendee.h"
#include "google/calendar_api/event_date_time.h"
#include "google/calendar_api/event_reminder.h"

namespace Json {
class Value;
}  // namespace Json

namespace google_calendar_api {
using namespace googleapis;

/**
 * No description provided.
 *
 * @ingroup DataObject
 */
class Event : public client::JsonCppData {
 public:
  /**
   * The creator of the event. Read-only.
   *
   * @ingroup DataObject
   */
  class EventCreator : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static EventCreator* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit EventCreator(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit EventCreator(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~EventCreator();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_calendar_api::EventCreator</code>
     */
    const char* GetTypeName() const {
      return "google_calendar_api::EventCreator";
    }

    /**
     * Determine if the '<code>displayName</code>' attribute was set.
     *
     * @return true if the '<code>displayName</code>' attribute was set.
     */
    bool has_display_name() const {
      return Storage().isMember("displayName");
    }

    /**
     * Clears the '<code>displayName</code>' attribute.
     */
    void clear_display_name() {
      MutableStorage()->removeMember("displayName");
    }


    /**
     * Get the value of the '<code>displayName</code>' attribute.
     */
    const StringPiece get_display_name() const {
      const Json::Value& v = Storage("displayName");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>displayName</code>' attribute.
     *
     * The creator's name, if available.
     *
     * @param[in] value The new value.
     */
    void set_display_name(const StringPiece& value) {
      *MutableStorage("displayName") = value.data();
    }

    /**
     * Determine if the '<code>email</code>' attribute was set.
     *
     * @return true if the '<code>email</code>' attribute was set.
     */
    bool has_email() const {
      return Storage().isMember("email");
    }

    /**
     * Clears the '<code>email</code>' attribute.
     */
    void clear_email() {
      MutableStorage()->removeMember("email");
    }


    /**
     * Get the value of the '<code>email</code>' attribute.
     */
    const StringPiece get_email() const {
      const Json::Value& v = Storage("email");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>email</code>' attribute.
     *
     * The creator's email address, if available.
     *
     * @param[in] value The new value.
     */
    void set_email(const StringPiece& value) {
      *MutableStorage("email") = value.data();
    }

    /**
     * Determine if the '<code>id</code>' attribute was set.
     *
     * @return true if the '<code>id</code>' attribute was set.
     */
    bool has_id() const {
      return Storage().isMember("id");
    }

    /**
     * Clears the '<code>id</code>' attribute.
     */
    void clear_id() {
      MutableStorage()->removeMember("id");
    }


    /**
     * Get the value of the '<code>id</code>' attribute.
     */
    const StringPiece get_id() const {
      const Json::Value& v = Storage("id");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>id</code>' attribute.
     *
     * The creator's Profile ID, if available. It corresponds to theid field in
     * the People collection of the Google+ API.
     *
     * @param[in] value The new value.
     */
    void set_id(const StringPiece& value) {
      *MutableStorage("id") = value.data();
    }

    /**
     * Determine if the '<code>self</code>' attribute was set.
     *
     * @return true if the '<code>self</code>' attribute was set.
     */
    bool has_self() const {
      return Storage().isMember("self");
    }

    /**
     * Clears the '<code>self</code>' attribute.
     */
    void clear_self() {
      MutableStorage()->removeMember("self");
    }


    /**
     * Get the value of the '<code>self</code>' attribute.
     */
    bool get_self() const {
      const Json::Value& storage = Storage("self");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>self</code>' attribute.
     *
     * Whether the creator corresponds to the calendar on which this copy of the
     * event appears. Read-only. The default is False.
     *
     * @param[in] value The new value.
     */
    void set_self(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("self"));
    }

   private:
    void operator=(const EventCreator&);
  };  // EventCreator
  /**
   * Extended properties of the event.
   *
   * @ingroup DataObject
   */
  class EventExtendedProperties : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static EventExtendedProperties* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit EventExtendedProperties(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit EventExtendedProperties(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~EventExtendedProperties();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_calendar_api::EventExtendedProperties</code>
     */
    const char* GetTypeName() const {
      return "google_calendar_api::EventExtendedProperties";
    }

    /**
     * Determine if the '<code>private</code>' attribute was set.
     *
     * @return true if the '<code>private</code>' attribute was set.
     */
    bool has_private() const {
      return Storage().isMember("private");
    }

    /**
     * Clears the '<code>private</code>' attribute.
     */
    void clear_private() {
      MutableStorage()->removeMember("private");
    }


    /**
     * Get a reference to the value of the '<code>private</code>' attribute.
     */
    const client::JsonCppAssociativeArray<string > get_private() const {
       const Json::Value& storage = Storage("private");
      return client::JsonValueToCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
    }

    /**
     * Gets a reference to a mutable value of the '<code>private</code>'
     * property.
     *
     * Properties that are private to the copy of the event that appears on this
     * calendar.
     *
     * @return The result can be modified to change the attribute value.
     */
    client::JsonCppAssociativeArray<string > mutable_private() {
      Json::Value* storage = MutableStorage("private");
      return client::JsonValueToMutableCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
    }

    /**
     * Determine if the '<code>shared</code>' attribute was set.
     *
     * @return true if the '<code>shared</code>' attribute was set.
     */
    bool has_shared() const {
      return Storage().isMember("shared");
    }

    /**
     * Clears the '<code>shared</code>' attribute.
     */
    void clear_shared() {
      MutableStorage()->removeMember("shared");
    }


    /**
     * Get a reference to the value of the '<code>shared</code>' attribute.
     */
    const client::JsonCppAssociativeArray<string > get_shared() const {
       const Json::Value& storage = Storage("shared");
      return client::JsonValueToCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
    }

    /**
     * Gets a reference to a mutable value of the '<code>shared</code>'
     * property.
     *
     * Properties that are shared between copies of the event on other
     * attendees' calendars.
     *
     * @return The result can be modified to change the attribute value.
     */
    client::JsonCppAssociativeArray<string > mutable_shared() {
      Json::Value* storage = MutableStorage("shared");
      return client::JsonValueToMutableCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
    }

   private:
    void operator=(const EventExtendedProperties&);
  };  // EventExtendedProperties
  /**
   * A gadget that extends this event.
   *
   * @ingroup DataObject
   */
  class EventGadget : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static EventGadget* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit EventGadget(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit EventGadget(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~EventGadget();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_calendar_api::EventGadget</code>
     */
    const char* GetTypeName() const {
      return "google_calendar_api::EventGadget";
    }

    /**
     * Determine if the '<code>display</code>' attribute was set.
     *
     * @return true if the '<code>display</code>' attribute was set.
     */
    bool has_display() const {
      return Storage().isMember("display");
    }

    /**
     * Clears the '<code>display</code>' attribute.
     */
    void clear_display() {
      MutableStorage()->removeMember("display");
    }


    /**
     * Get the value of the '<code>display</code>' attribute.
     */
    const StringPiece get_display() const {
      const Json::Value& v = Storage("display");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>display</code>' attribute.
     *
     * The gadget's display mode. Optional. Possible values are:
     * <dl>
     * <dt>"icon"
     * <dd>The gadget displays next to the event's title in the calendar view.
     * <dt>"chip"
     * <dd>The gadget displays when the event is clicked.
     * </dl>
     *
     *
     * @param[in] value The new value.
     */
    void set_display(const StringPiece& value) {
      *MutableStorage("display") = value.data();
    }

    /**
     * Determine if the '<code>height</code>' attribute was set.
     *
     * @return true if the '<code>height</code>' attribute was set.
     */
    bool has_height() const {
      return Storage().isMember("height");
    }

    /**
     * Clears the '<code>height</code>' attribute.
     */
    void clear_height() {
      MutableStorage()->removeMember("height");
    }


    /**
     * Get the value of the '<code>height</code>' attribute.
     */
    int32 get_height() const {
      const Json::Value& storage = Storage("height");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>height</code>' attribute.
     *
     * The gadget's height in pixels. The height must be an integer greater than
     * 0. Optional.
     *
     * @param[in] value The new value.
     */
    void set_height(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("height"));
    }

    /**
     * Determine if the '<code>iconLink</code>' attribute was set.
     *
     * @return true if the '<code>iconLink</code>' attribute was set.
     */
    bool has_icon_link() const {
      return Storage().isMember("iconLink");
    }

    /**
     * Clears the '<code>iconLink</code>' attribute.
     */
    void clear_icon_link() {
      MutableStorage()->removeMember("iconLink");
    }


    /**
     * Get the value of the '<code>iconLink</code>' attribute.
     */
    const StringPiece get_icon_link() const {
      const Json::Value& v = Storage("iconLink");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>iconLink</code>' attribute.
     *
     * The gadget's icon URL. The URL scheme must be HTTPS.
     *
     * @param[in] value The new value.
     */
    void set_icon_link(const StringPiece& value) {
      *MutableStorage("iconLink") = value.data();
    }

    /**
     * Determine if the '<code>link</code>' attribute was set.
     *
     * @return true if the '<code>link</code>' attribute was set.
     */
    bool has_link() const {
      return Storage().isMember("link");
    }

    /**
     * Clears the '<code>link</code>' attribute.
     */
    void clear_link() {
      MutableStorage()->removeMember("link");
    }


    /**
     * Get the value of the '<code>link</code>' attribute.
     */
    const StringPiece get_link() const {
      const Json::Value& v = Storage("link");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>link</code>' attribute.
     *
     * The gadget's URL. The URL scheme must be HTTPS.
     *
     * @param[in] value The new value.
     */
    void set_link(const StringPiece& value) {
      *MutableStorage("link") = value.data();
    }

    /**
     * Determine if the '<code>preferences</code>' attribute was set.
     *
     * @return true if the '<code>preferences</code>' attribute was set.
     */
    bool has_preferences() const {
      return Storage().isMember("preferences");
    }

    /**
     * Clears the '<code>preferences</code>' attribute.
     */
    void clear_preferences() {
      MutableStorage()->removeMember("preferences");
    }


    /**
     * Get a reference to the value of the '<code>preferences</code>' attribute.
     */
    const client::JsonCppAssociativeArray<string > get_preferences() const {
       const Json::Value& storage = Storage("preferences");
      return client::JsonValueToCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
    }

    /**
     * Gets a reference to a mutable value of the '<code>preferences</code>'
     * property.
     *
     * Preferences.
     *
     * @return The result can be modified to change the attribute value.
     */
    client::JsonCppAssociativeArray<string > mutable_preferences() {
      Json::Value* storage = MutableStorage("preferences");
      return client::JsonValueToMutableCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
    }

    /**
     * Determine if the '<code>title</code>' attribute was set.
     *
     * @return true if the '<code>title</code>' attribute was set.
     */
    bool has_title() const {
      return Storage().isMember("title");
    }

    /**
     * Clears the '<code>title</code>' attribute.
     */
    void clear_title() {
      MutableStorage()->removeMember("title");
    }


    /**
     * Get the value of the '<code>title</code>' attribute.
     */
    const StringPiece get_title() const {
      const Json::Value& v = Storage("title");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>title</code>' attribute.
     *
     * The gadget's title.
     *
     * @param[in] value The new value.
     */
    void set_title(const StringPiece& value) {
      *MutableStorage("title") = value.data();
    }

    /**
     * Determine if the '<code>type</code>' attribute was set.
     *
     * @return true if the '<code>type</code>' attribute was set.
     */
    bool has_type() const {
      return Storage().isMember("type");
    }

    /**
     * Clears the '<code>type</code>' attribute.
     */
    void clear_type() {
      MutableStorage()->removeMember("type");
    }


    /**
     * Get the value of the '<code>type</code>' attribute.
     */
    const StringPiece get_type() const {
      const Json::Value& v = Storage("type");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>type</code>' attribute.
     *
     * The gadget's type.
     *
     * @param[in] value The new value.
     */
    void set_type(const StringPiece& value) {
      *MutableStorage("type") = value.data();
    }

    /**
     * Determine if the '<code>width</code>' attribute was set.
     *
     * @return true if the '<code>width</code>' attribute was set.
     */
    bool has_width() const {
      return Storage().isMember("width");
    }

    /**
     * Clears the '<code>width</code>' attribute.
     */
    void clear_width() {
      MutableStorage()->removeMember("width");
    }


    /**
     * Get the value of the '<code>width</code>' attribute.
     */
    int32 get_width() const {
      const Json::Value& storage = Storage("width");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>width</code>' attribute.
     *
     * The gadget's width in pixels. The width must be an integer greater than
     * 0. Optional.
     *
     * @param[in] value The new value.
     */
    void set_width(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("width"));
    }

   private:
    void operator=(const EventGadget&);
  };  // EventGadget
  /**
   * The organizer of the event. If the organizer is also an attendee, this is
   * indicated with a separate entry in attendees with the organizer field set
   * to True. To change the organizer, use the move operation. Read-only, except
   * when importing an event.
   *
   * @ingroup DataObject
   */
  class EventOrganizer : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static EventOrganizer* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit EventOrganizer(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit EventOrganizer(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~EventOrganizer();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_calendar_api::EventOrganizer</code>
     */
    const char* GetTypeName() const {
      return "google_calendar_api::EventOrganizer";
    }

    /**
     * Determine if the '<code>displayName</code>' attribute was set.
     *
     * @return true if the '<code>displayName</code>' attribute was set.
     */
    bool has_display_name() const {
      return Storage().isMember("displayName");
    }

    /**
     * Clears the '<code>displayName</code>' attribute.
     */
    void clear_display_name() {
      MutableStorage()->removeMember("displayName");
    }


    /**
     * Get the value of the '<code>displayName</code>' attribute.
     */
    const StringPiece get_display_name() const {
      const Json::Value& v = Storage("displayName");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>displayName</code>' attribute.
     *
     * The organizer's name, if available.
     *
     * @param[in] value The new value.
     */
    void set_display_name(const StringPiece& value) {
      *MutableStorage("displayName") = value.data();
    }

    /**
     * Determine if the '<code>email</code>' attribute was set.
     *
     * @return true if the '<code>email</code>' attribute was set.
     */
    bool has_email() const {
      return Storage().isMember("email");
    }

    /**
     * Clears the '<code>email</code>' attribute.
     */
    void clear_email() {
      MutableStorage()->removeMember("email");
    }


    /**
     * Get the value of the '<code>email</code>' attribute.
     */
    const StringPiece get_email() const {
      const Json::Value& v = Storage("email");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>email</code>' attribute.
     *
     * The organizer's email address, if available. It must be a valid email
     * address as per RFC5322.
     *
     * @param[in] value The new value.
     */
    void set_email(const StringPiece& value) {
      *MutableStorage("email") = value.data();
    }

    /**
     * Determine if the '<code>id</code>' attribute was set.
     *
     * @return true if the '<code>id</code>' attribute was set.
     */
    bool has_id() const {
      return Storage().isMember("id");
    }

    /**
     * Clears the '<code>id</code>' attribute.
     */
    void clear_id() {
      MutableStorage()->removeMember("id");
    }


    /**
     * Get the value of the '<code>id</code>' attribute.
     */
    const StringPiece get_id() const {
      const Json::Value& v = Storage("id");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>id</code>' attribute.
     *
     * The organizer's Profile ID, if available. It corresponds to theid field
     * in the People collection of the Google+ API.
     *
     * @param[in] value The new value.
     */
    void set_id(const StringPiece& value) {
      *MutableStorage("id") = value.data();
    }

    /**
     * Determine if the '<code>self</code>' attribute was set.
     *
     * @return true if the '<code>self</code>' attribute was set.
     */
    bool has_self() const {
      return Storage().isMember("self");
    }

    /**
     * Clears the '<code>self</code>' attribute.
     */
    void clear_self() {
      MutableStorage()->removeMember("self");
    }


    /**
     * Get the value of the '<code>self</code>' attribute.
     */
    bool get_self() const {
      const Json::Value& storage = Storage("self");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>self</code>' attribute.
     *
     * Whether the organizer corresponds to the calendar on which this copy of
     * the event appears. Read-only. The default is False.
     *
     * @param[in] value The new value.
     */
    void set_self(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("self"));
    }

   private:
    void operator=(const EventOrganizer&);
  };  // EventOrganizer
  /**
   * Information about the event's reminders for the authenticated user.
   *
   * @ingroup DataObject
   */
  class EventReminders : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static EventReminders* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit EventReminders(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit EventReminders(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~EventReminders();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_calendar_api::EventReminders</code>
     */
    const char* GetTypeName() const {
      return "google_calendar_api::EventReminders";
    }

    /**
     * Determine if the '<code>overrides</code>' attribute was set.
     *
     * @return true if the '<code>overrides</code>' attribute was set.
     */
    bool has_overrides() const {
      return Storage().isMember("overrides");
    }

    /**
     * Clears the '<code>overrides</code>' attribute.
     */
    void clear_overrides() {
      MutableStorage()->removeMember("overrides");
    }


    /**
     * Get a reference to the value of the '<code>overrides</code>' attribute.
     */
    const client::JsonCppArray<EventReminder > get_overrides() const;

    /**
     * Gets a reference to a mutable value of the '<code>overrides</code>'
     * property.
     *
     * If the event doesn't use the default reminders, this lists the reminders
     * specific to the event, or, if not set, indicates that no reminders are
     * set for this event. The maximum number of override reminders is 5.
     *
     * @return The result can be modified to change the attribute value.
     */
    client::JsonCppArray<EventReminder > mutable_overrides();

    /**
     * Determine if the '<code>useDefault</code>' attribute was set.
     *
     * @return true if the '<code>useDefault</code>' attribute was set.
     */
    bool has_use_default() const {
      return Storage().isMember("useDefault");
    }

    /**
     * Clears the '<code>useDefault</code>' attribute.
     */
    void clear_use_default() {
      MutableStorage()->removeMember("useDefault");
    }


    /**
     * Get the value of the '<code>useDefault</code>' attribute.
     */
    bool get_use_default() const {
      const Json::Value& storage = Storage("useDefault");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>useDefault</code>' attribute.
     *
     * Whether the default reminders of the calendar apply to the event.
     *
     * @param[in] value The new value.
     */
    void set_use_default(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("useDefault"));
    }

   private:
    void operator=(const EventReminders&);
  };  // EventReminders
  /**
   * Source from which the event was created. For example, a web page, an email
   * message or any document identifiable by an URL with HTTP or HTTPS scheme.
   * Can only be seen or modified by the creator of the event.
   *
   * @ingroup DataObject
   */
  class EventSource : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static EventSource* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit EventSource(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit EventSource(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~EventSource();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_calendar_api::EventSource</code>
     */
    const char* GetTypeName() const {
      return "google_calendar_api::EventSource";
    }

    /**
     * Determine if the '<code>title</code>' attribute was set.
     *
     * @return true if the '<code>title</code>' attribute was set.
     */
    bool has_title() const {
      return Storage().isMember("title");
    }

    /**
     * Clears the '<code>title</code>' attribute.
     */
    void clear_title() {
      MutableStorage()->removeMember("title");
    }


    /**
     * Get the value of the '<code>title</code>' attribute.
     */
    const StringPiece get_title() const {
      const Json::Value& v = Storage("title");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>title</code>' attribute.
     *
     * Title of the source; for example a title of a web page or an email
     * subject.
     *
     * @param[in] value The new value.
     */
    void set_title(const StringPiece& value) {
      *MutableStorage("title") = value.data();
    }

    /**
     * Determine if the '<code>url</code>' attribute was set.
     *
     * @return true if the '<code>url</code>' attribute was set.
     */
    bool has_url() const {
      return Storage().isMember("url");
    }

    /**
     * Clears the '<code>url</code>' attribute.
     */
    void clear_url() {
      MutableStorage()->removeMember("url");
    }


    /**
     * Get the value of the '<code>url</code>' attribute.
     */
    const StringPiece get_url() const {
      const Json::Value& v = Storage("url");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>url</code>' attribute.
     *
     * URL of the source pointing to a resource. The URL scheme must be HTTP or
     * HTTPS.
     *
     * @param[in] value The new value.
     */
    void set_url(const StringPiece& value) {
      *MutableStorage("url") = value.data();
    }

   private:
    void operator=(const EventSource&);
  };  // EventSource
  /**
   * Creates a new default instance.
   *
   * @return Ownership is passed back to the caller.
   */
  static Event* New();

  /**
   * Standard constructor for an immutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit Event(const Json::Value& storage);

  /**
   * Standard constructor for a mutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit Event(Json::Value* storage);

  /**
   * Standard destructor.
   */
  virtual ~Event();

  /**
   * Returns a string denoting the type of this data object.
   *
   * @return <code>google_calendar_api::Event</code>
   */
  const char* GetTypeName() const {
    return "google_calendar_api::Event";
  }

  /**
   * Determine if the '<code>anyoneCanAddSelf</code>' attribute was set.
   *
   * @return true if the '<code>anyoneCanAddSelf</code>' attribute was set.
   */
  bool has_anyone_can_add_self() const {
    return Storage().isMember("anyoneCanAddSelf");
  }

  /**
   * Clears the '<code>anyoneCanAddSelf</code>' attribute.
   */
  void clear_anyone_can_add_self() {
    MutableStorage()->removeMember("anyoneCanAddSelf");
  }


  /**
   * Get the value of the '<code>anyoneCanAddSelf</code>' attribute.
   */
  bool get_anyone_can_add_self() const {
    const Json::Value& storage = Storage("anyoneCanAddSelf");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>anyoneCanAddSelf</code>' attribute.
   *
   * Whether anyone can invite themselves to the event (currently works for
   * Google+ events only). Optional. The default is False.
   *
   * @param[in] value The new value.
   */
  void set_anyone_can_add_self(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("anyoneCanAddSelf"));
  }

  /**
   * Determine if the '<code>attachments</code>' attribute was set.
   *
   * @return true if the '<code>attachments</code>' attribute was set.
   */
  bool has_attachments() const {
    return Storage().isMember("attachments");
  }

  /**
   * Clears the '<code>attachments</code>' attribute.
   */
  void clear_attachments() {
    MutableStorage()->removeMember("attachments");
  }


  /**
   * Get a reference to the value of the '<code>attachments</code>' attribute.
   */
  const client::JsonCppArray<EventAttachment > get_attachments() const;

  /**
   * Gets a reference to a mutable value of the '<code>attachments</code>'
   * property.
   *
   * File attachments for the event. Currently only Google Drive attachments are
   * supported.
   * In order to modify attachments the supportsAttachments request parameter
   * should be set to true.
   * There can be at most 25 attachments per event,.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<EventAttachment > mutable_attachments();

  /**
   * Determine if the '<code>attendees</code>' attribute was set.
   *
   * @return true if the '<code>attendees</code>' attribute was set.
   */
  bool has_attendees() const {
    return Storage().isMember("attendees");
  }

  /**
   * Clears the '<code>attendees</code>' attribute.
   */
  void clear_attendees() {
    MutableStorage()->removeMember("attendees");
  }


  /**
   * Get a reference to the value of the '<code>attendees</code>' attribute.
   */
  const client::JsonCppArray<EventAttendee > get_attendees() const;

  /**
   * Gets a reference to a mutable value of the '<code>attendees</code>'
   * property.
   *
   * The attendees of the event. See the Events with attendees guide for more
   * information on scheduling events with other calendar users.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<EventAttendee > mutable_attendees();

  /**
   * Determine if the '<code>attendeesOmitted</code>' attribute was set.
   *
   * @return true if the '<code>attendeesOmitted</code>' attribute was set.
   */
  bool has_attendees_omitted() const {
    return Storage().isMember("attendeesOmitted");
  }

  /**
   * Clears the '<code>attendeesOmitted</code>' attribute.
   */
  void clear_attendees_omitted() {
    MutableStorage()->removeMember("attendeesOmitted");
  }


  /**
   * Get the value of the '<code>attendeesOmitted</code>' attribute.
   */
  bool get_attendees_omitted() const {
    const Json::Value& storage = Storage("attendeesOmitted");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>attendeesOmitted</code>' attribute.
   *
   * Whether attendees may have been omitted from the event's representation.
   * When retrieving an event, this may be due to a restriction specified by the
   * maxAttendee query parameter. When updating an event, this can be used to
   * only update the participant's response. Optional. The default is False.
   *
   * @param[in] value The new value.
   */
  void set_attendees_omitted(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("attendeesOmitted"));
  }

  /**
   * Determine if the '<code>colorId</code>' attribute was set.
   *
   * @return true if the '<code>colorId</code>' attribute was set.
   */
  bool has_color_id() const {
    return Storage().isMember("colorId");
  }

  /**
   * Clears the '<code>colorId</code>' attribute.
   */
  void clear_color_id() {
    MutableStorage()->removeMember("colorId");
  }


  /**
   * Get the value of the '<code>colorId</code>' attribute.
   */
  const StringPiece get_color_id() const {
    const Json::Value& v = Storage("colorId");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>colorId</code>' attribute.
   *
   * The color of the event. This is an ID referring to an entry in the event
   * section of the colors definition (see the  colors endpoint). Optional.
   *
   * @param[in] value The new value.
   */
  void set_color_id(const StringPiece& value) {
    *MutableStorage("colorId") = value.data();
  }

  /**
   * Determine if the '<code>created</code>' attribute was set.
   *
   * @return true if the '<code>created</code>' attribute was set.
   */
  bool has_created() const {
    return Storage().isMember("created");
  }

  /**
   * Clears the '<code>created</code>' attribute.
   */
  void clear_created() {
    MutableStorage()->removeMember("created");
  }


  /**
   * Get the value of the '<code>created</code>' attribute.
   */
  client::DateTime get_created() const {
    const Json::Value& storage = Storage("created");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>created</code>' attribute.
   *
   * Creation time of the event (as a RFC3339 timestamp). Read-only.
   *
   * @param[in] value The new value.
   */
  void set_created(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("created"));
  }

  /**
   * Determine if the '<code>creator</code>' attribute was set.
   *
   * @return true if the '<code>creator</code>' attribute was set.
   */
  bool has_creator() const {
    return Storage().isMember("creator");
  }

  /**
   * Clears the '<code>creator</code>' attribute.
   */
  void clear_creator() {
    MutableStorage()->removeMember("creator");
  }


  /**
   * Get a reference to the value of the '<code>creator</code>' attribute.
   */
  const EventCreator get_creator() const {
     const Json::Value& storage = Storage("creator");
    return client::JsonValueToCppValueHelper<EventCreator >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>creator</code>' property.
   *
   * The creator of the event. Read-only.
   *
   * @return The result can be modified to change the attribute value.
   */
  EventCreator mutable_creator() {
    Json::Value* storage = MutableStorage("creator");
    return client::JsonValueToMutableCppValueHelper<EventCreator >(storage);
  }

  /**
   * Determine if the '<code>description</code>' attribute was set.
   *
   * @return true if the '<code>description</code>' attribute was set.
   */
  bool has_description() const {
    return Storage().isMember("description");
  }

  /**
   * Clears the '<code>description</code>' attribute.
   */
  void clear_description() {
    MutableStorage()->removeMember("description");
  }


  /**
   * Get the value of the '<code>description</code>' attribute.
   */
  const StringPiece get_description() const {
    const Json::Value& v = Storage("description");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>description</code>' attribute.
   *
   * Description of the event. Optional.
   *
   * @param[in] value The new value.
   */
  void set_description(const StringPiece& value) {
    *MutableStorage("description") = value.data();
  }

  /**
   * Determine if the '<code>end</code>' attribute was set.
   *
   * @return true if the '<code>end</code>' attribute was set.
   */
  bool has_end() const {
    return Storage().isMember("end");
  }

  /**
   * Clears the '<code>end</code>' attribute.
   */
  void clear_end() {
    MutableStorage()->removeMember("end");
  }


  /**
   * Get a reference to the value of the '<code>end</code>' attribute.
   */
  const EventDateTime get_end() const;

  /**
   * Gets a reference to a mutable value of the '<code>end</code>' property.
   *
   * The (exclusive) end time of the event. For a recurring event, this is the
   * end time of the first instance.
   *
   * @return The result can be modified to change the attribute value.
   */
  EventDateTime mutable_end();

  /**
   * Determine if the '<code>endTimeUnspecified</code>' attribute was set.
   *
   * @return true if the '<code>endTimeUnspecified</code>' attribute was set.
   */
  bool has_end_time_unspecified() const {
    return Storage().isMember("endTimeUnspecified");
  }

  /**
   * Clears the '<code>endTimeUnspecified</code>' attribute.
   */
  void clear_end_time_unspecified() {
    MutableStorage()->removeMember("endTimeUnspecified");
  }


  /**
   * Get the value of the '<code>endTimeUnspecified</code>' attribute.
   */
  bool get_end_time_unspecified() const {
    const Json::Value& storage = Storage("endTimeUnspecified");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>endTimeUnspecified</code>' attribute.
   *
   * Whether the end time is actually unspecified. An end time is still provided
   * for compatibility reasons, even if this attribute is set to True. The
   * default is False.
   *
   * @param[in] value The new value.
   */
  void set_end_time_unspecified(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("endTimeUnspecified"));
  }

  /**
   * Determine if the '<code>etag</code>' attribute was set.
   *
   * @return true if the '<code>etag</code>' attribute was set.
   */
  bool has_etag() const {
    return Storage().isMember("etag");
  }

  /**
   * Clears the '<code>etag</code>' attribute.
   */
  void clear_etag() {
    MutableStorage()->removeMember("etag");
  }


  /**
   * Get the value of the '<code>etag</code>' attribute.
   */
  const StringPiece get_etag() const {
    const Json::Value& v = Storage("etag");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>etag</code>' attribute.
   *
   * ETag of the resource.
   *
   * @param[in] value The new value.
   */
  void set_etag(const StringPiece& value) {
    *MutableStorage("etag") = value.data();
  }

  /**
   * Determine if the '<code>extendedProperties</code>' attribute was set.
   *
   * @return true if the '<code>extendedProperties</code>' attribute was set.
   */
  bool has_extended_properties() const {
    return Storage().isMember("extendedProperties");
  }

  /**
   * Clears the '<code>extendedProperties</code>' attribute.
   */
  void clear_extended_properties() {
    MutableStorage()->removeMember("extendedProperties");
  }


  /**
   * Get a reference to the value of the '<code>extendedProperties</code>'
   * attribute.
   */
  const EventExtendedProperties get_extended_properties() const {
     const Json::Value& storage = Storage("extendedProperties");
    return client::JsonValueToCppValueHelper<EventExtendedProperties >(storage);
  }

  /**
   * Gets a reference to a mutable value of the
   * '<code>extendedProperties</code>' property.
   *
   * Extended properties of the event.
   *
   * @return The result can be modified to change the attribute value.
   */
  EventExtendedProperties mutable_extendedProperties() {
    Json::Value* storage = MutableStorage("extendedProperties");
    return client::JsonValueToMutableCppValueHelper<EventExtendedProperties >(storage);
  }

  /**
   * Determine if the '<code>gadget</code>' attribute was set.
   *
   * @return true if the '<code>gadget</code>' attribute was set.
   */
  bool has_gadget() const {
    return Storage().isMember("gadget");
  }

  /**
   * Clears the '<code>gadget</code>' attribute.
   */
  void clear_gadget() {
    MutableStorage()->removeMember("gadget");
  }


  /**
   * Get a reference to the value of the '<code>gadget</code>' attribute.
   */
  const EventGadget get_gadget() const {
     const Json::Value& storage = Storage("gadget");
    return client::JsonValueToCppValueHelper<EventGadget >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>gadget</code>' property.
   *
   * A gadget that extends this event.
   *
   * @return The result can be modified to change the attribute value.
   */
  EventGadget mutable_gadget() {
    Json::Value* storage = MutableStorage("gadget");
    return client::JsonValueToMutableCppValueHelper<EventGadget >(storage);
  }

  /**
   * Determine if the '<code>guestsCanInviteOthers</code>' attribute was set.
   *
   * @return true if the '<code>guestsCanInviteOthers</code>' attribute was set.
   */
  bool has_guests_can_invite_others() const {
    return Storage().isMember("guestsCanInviteOthers");
  }

  /**
   * Clears the '<code>guestsCanInviteOthers</code>' attribute.
   */
  void clear_guests_can_invite_others() {
    MutableStorage()->removeMember("guestsCanInviteOthers");
  }


  /**
   * Get the value of the '<code>guestsCanInviteOthers</code>' attribute.
   */
  bool get_guests_can_invite_others() const {
    const Json::Value& storage = Storage("guestsCanInviteOthers");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>guestsCanInviteOthers</code>' attribute.
   *
   * Whether attendees other than the organizer can invite others to the event.
   * Optional. The default is True.
   *
   * @param[in] value The new value.
   */
  void set_guests_can_invite_others(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("guestsCanInviteOthers"));
  }

  /**
   * Determine if the '<code>guestsCanModify</code>' attribute was set.
   *
   * @return true if the '<code>guestsCanModify</code>' attribute was set.
   */
  bool has_guests_can_modify() const {
    return Storage().isMember("guestsCanModify");
  }

  /**
   * Clears the '<code>guestsCanModify</code>' attribute.
   */
  void clear_guests_can_modify() {
    MutableStorage()->removeMember("guestsCanModify");
  }


  /**
   * Get the value of the '<code>guestsCanModify</code>' attribute.
   */
  bool get_guests_can_modify() const {
    const Json::Value& storage = Storage("guestsCanModify");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>guestsCanModify</code>' attribute.
   *
   * Whether attendees other than the organizer can modify the event. Optional.
   * The default is False.
   *
   * @param[in] value The new value.
   */
  void set_guests_can_modify(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("guestsCanModify"));
  }

  /**
   * Determine if the '<code>guestsCanSeeOtherGuests</code>' attribute was set.
   *
   * @return true if the '<code>guestsCanSeeOtherGuests</code>' attribute was
   * set.
   */
  bool has_guests_can_see_other_guests() const {
    return Storage().isMember("guestsCanSeeOtherGuests");
  }

  /**
   * Clears the '<code>guestsCanSeeOtherGuests</code>' attribute.
   */
  void clear_guests_can_see_other_guests() {
    MutableStorage()->removeMember("guestsCanSeeOtherGuests");
  }


  /**
   * Get the value of the '<code>guestsCanSeeOtherGuests</code>' attribute.
   */
  bool get_guests_can_see_other_guests() const {
    const Json::Value& storage = Storage("guestsCanSeeOtherGuests");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>guestsCanSeeOtherGuests</code>' attribute.
   *
   * Whether attendees other than the organizer can see who the event's
   * attendees are. Optional. The default is True.
   *
   * @param[in] value The new value.
   */
  void set_guests_can_see_other_guests(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("guestsCanSeeOtherGuests"));
  }

  /**
   * Determine if the '<code>hangoutLink</code>' attribute was set.
   *
   * @return true if the '<code>hangoutLink</code>' attribute was set.
   */
  bool has_hangout_link() const {
    return Storage().isMember("hangoutLink");
  }

  /**
   * Clears the '<code>hangoutLink</code>' attribute.
   */
  void clear_hangout_link() {
    MutableStorage()->removeMember("hangoutLink");
  }


  /**
   * Get the value of the '<code>hangoutLink</code>' attribute.
   */
  const StringPiece get_hangout_link() const {
    const Json::Value& v = Storage("hangoutLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>hangoutLink</code>' attribute.
   *
   * An absolute link to the Google+ hangout associated with this event. Read-
   * only.
   *
   * @param[in] value The new value.
   */
  void set_hangout_link(const StringPiece& value) {
    *MutableStorage("hangoutLink") = value.data();
  }

  /**
   * Determine if the '<code>htmlLink</code>' attribute was set.
   *
   * @return true if the '<code>htmlLink</code>' attribute was set.
   */
  bool has_html_link() const {
    return Storage().isMember("htmlLink");
  }

  /**
   * Clears the '<code>htmlLink</code>' attribute.
   */
  void clear_html_link() {
    MutableStorage()->removeMember("htmlLink");
  }


  /**
   * Get the value of the '<code>htmlLink</code>' attribute.
   */
  const StringPiece get_html_link() const {
    const Json::Value& v = Storage("htmlLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>htmlLink</code>' attribute.
   *
   * An absolute link to this event in the Google Calendar Web UI. Read-only.
   *
   * @param[in] value The new value.
   */
  void set_html_link(const StringPiece& value) {
    *MutableStorage("htmlLink") = value.data();
  }

  /**
   * Determine if the '<code>iCalUID</code>' attribute was set.
   *
   * @return true if the '<code>iCalUID</code>' attribute was set.
   */
  bool has_i_cal_uid() const {
    return Storage().isMember("iCalUID");
  }

  /**
   * Clears the '<code>iCalUID</code>' attribute.
   */
  void clear_i_cal_uid() {
    MutableStorage()->removeMember("iCalUID");
  }


  /**
   * Get the value of the '<code>iCalUID</code>' attribute.
   */
  const StringPiece get_i_cal_uid() const {
    const Json::Value& v = Storage("iCalUID");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>iCalUID</code>' attribute.
   *
   * Event unique identifier as defined in RFC5545. It is used to uniquely
   * identify events accross calendaring systems and must be supplied when
   * importing events via the import method.
   * Note that the icalUID and the id are not identical and only one of them
   * should be supplied at event creation time. One difference in their
   * semantics is that in recurring events, all occurrences of one event have
   * different ids while they all share the same icalUIDs.
   *
   * @param[in] value The new value.
   */
  void set_i_cal_uid(const StringPiece& value) {
    *MutableStorage("iCalUID") = value.data();
  }

  /**
   * Determine if the '<code>id</code>' attribute was set.
   *
   * @return true if the '<code>id</code>' attribute was set.
   */
  bool has_id() const {
    return Storage().isMember("id");
  }

  /**
   * Clears the '<code>id</code>' attribute.
   */
  void clear_id() {
    MutableStorage()->removeMember("id");
  }


  /**
   * Get the value of the '<code>id</code>' attribute.
   */
  const StringPiece get_id() const {
    const Json::Value& v = Storage("id");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>id</code>' attribute.
   *
   * Opaque identifier of the event. When creating new single or recurring
   * events, you can specify their IDs. Provided IDs must follow these rules:
   * - characters allowed in the ID are those used in base32hex encoding, i.e.
   * lowercase letters a-v and digits 0-9, see section 3.1.2 in RFC2938
   * - the length of the ID must be between 5 and 1024 characters
   * - the ID must be unique per calendar  Due to the globally distributed
   * nature of the system, we cannot guarantee that ID collisions will be
   * detected at event creation time. To minimize the risk of collisions we
   * recommend using an established UUID algorithm such as one described in
   * RFC4122.
   * If you do not specify an ID, it will be automatically generated by the
   * server.
   * Note that the icalUID and the id are not identical and only one of them
   * should be supplied at event creation time. One difference in their
   * semantics is that in recurring events, all occurrences of one event have
   * different ids while they all share the same icalUIDs.
   *
   * @param[in] value The new value.
   */
  void set_id(const StringPiece& value) {
    *MutableStorage("id") = value.data();
  }

  /**
   * Determine if the '<code>kind</code>' attribute was set.
   *
   * @return true if the '<code>kind</code>' attribute was set.
   */
  bool has_kind() const {
    return Storage().isMember("kind");
  }

  /**
   * Clears the '<code>kind</code>' attribute.
   */
  void clear_kind() {
    MutableStorage()->removeMember("kind");
  }


  /**
   * Get the value of the '<code>kind</code>' attribute.
   */
  const StringPiece get_kind() const {
    const Json::Value& v = Storage("kind");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>kind</code>' attribute.
   *
   * Type of the resource ("calendar#event").
   *
   * @param[in] value The new value.
   */
  void set_kind(const StringPiece& value) {
    *MutableStorage("kind") = value.data();
  }

  /**
   * Determine if the '<code>location</code>' attribute was set.
   *
   * @return true if the '<code>location</code>' attribute was set.
   */
  bool has_location() const {
    return Storage().isMember("location");
  }

  /**
   * Clears the '<code>location</code>' attribute.
   */
  void clear_location() {
    MutableStorage()->removeMember("location");
  }


  /**
   * Get the value of the '<code>location</code>' attribute.
   */
  const StringPiece get_location() const {
    const Json::Value& v = Storage("location");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>location</code>' attribute.
   *
   * Geographic location of the event as free-form text. Optional.
   *
   * @param[in] value The new value.
   */
  void set_location(const StringPiece& value) {
    *MutableStorage("location") = value.data();
  }

  /**
   * Determine if the '<code>locked</code>' attribute was set.
   *
   * @return true if the '<code>locked</code>' attribute was set.
   */
  bool has_locked() const {
    return Storage().isMember("locked");
  }

  /**
   * Clears the '<code>locked</code>' attribute.
   */
  void clear_locked() {
    MutableStorage()->removeMember("locked");
  }


  /**
   * Get the value of the '<code>locked</code>' attribute.
   */
  bool get_locked() const {
    const Json::Value& storage = Storage("locked");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>locked</code>' attribute.
   *
   * Whether this is a locked event copy where no changes can be made to the
   * main event fields "summary", "description", "location", "start", "end" or
   * "recurrence". The default is False. Read-Only.
   *
   * @param[in] value The new value.
   */
  void set_locked(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("locked"));
  }

  /**
   * Determine if the '<code>organizer</code>' attribute was set.
   *
   * @return true if the '<code>organizer</code>' attribute was set.
   */
  bool has_organizer() const {
    return Storage().isMember("organizer");
  }

  /**
   * Clears the '<code>organizer</code>' attribute.
   */
  void clear_organizer() {
    MutableStorage()->removeMember("organizer");
  }


  /**
   * Get a reference to the value of the '<code>organizer</code>' attribute.
   */
  const EventOrganizer get_organizer() const {
     const Json::Value& storage = Storage("organizer");
    return client::JsonValueToCppValueHelper<EventOrganizer >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>organizer</code>'
   * property.
   *
   * The organizer of the event. If the organizer is also an attendee, this is
   * indicated with a separate entry in attendees with the organizer field set
   * to True. To change the organizer, use the move operation. Read-only, except
   * when importing an event.
   *
   * @return The result can be modified to change the attribute value.
   */
  EventOrganizer mutable_organizer() {
    Json::Value* storage = MutableStorage("organizer");
    return client::JsonValueToMutableCppValueHelper<EventOrganizer >(storage);
  }

  /**
   * Determine if the '<code>originalStartTime</code>' attribute was set.
   *
   * @return true if the '<code>originalStartTime</code>' attribute was set.
   */
  bool has_original_start_time() const {
    return Storage().isMember("originalStartTime");
  }

  /**
   * Clears the '<code>originalStartTime</code>' attribute.
   */
  void clear_original_start_time() {
    MutableStorage()->removeMember("originalStartTime");
  }


  /**
   * Get a reference to the value of the '<code>originalStartTime</code>'
   * attribute.
   */
  const EventDateTime get_original_start_time() const;

  /**
   * Gets a reference to a mutable value of the '<code>originalStartTime</code>'
   * property.
   *
   * For an instance of a recurring event, this is the time at which this event
   * would start according to the recurrence data in the recurring event
   * identified by recurringEventId. Immutable.
   *
   * @return The result can be modified to change the attribute value.
   */
  EventDateTime mutable_originalStartTime();

  /**
   * Determine if the '<code>privateCopy</code>' attribute was set.
   *
   * @return true if the '<code>privateCopy</code>' attribute was set.
   */
  bool has_private_copy() const {
    return Storage().isMember("privateCopy");
  }

  /**
   * Clears the '<code>privateCopy</code>' attribute.
   */
  void clear_private_copy() {
    MutableStorage()->removeMember("privateCopy");
  }


  /**
   * Get the value of the '<code>privateCopy</code>' attribute.
   */
  bool get_private_copy() const {
    const Json::Value& storage = Storage("privateCopy");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>privateCopy</code>' attribute.
   *
   * Whether this is a private event copy where changes are not shared with
   * other copies on other calendars. Optional. Immutable. The default is False.
   *
   * @param[in] value The new value.
   */
  void set_private_copy(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("privateCopy"));
  }

  /**
   * Determine if the '<code>recurrence</code>' attribute was set.
   *
   * @return true if the '<code>recurrence</code>' attribute was set.
   */
  bool has_recurrence() const {
    return Storage().isMember("recurrence");
  }

  /**
   * Clears the '<code>recurrence</code>' attribute.
   */
  void clear_recurrence() {
    MutableStorage()->removeMember("recurrence");
  }


  /**
   * Get a reference to the value of the '<code>recurrence</code>' attribute.
   */
  const client::JsonCppArray<string > get_recurrence() const {
     const Json::Value& storage = Storage("recurrence");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>recurrence</code>'
   * property.
   *
   * List of RRULE, EXRULE, RDATE and EXDATE lines for a recurring event, as
   * specified in RFC5545. Note that DTSTART and DTEND lines are not allowed in
   * this field; event start and end times are specified in the start and end
   * fields. This field is omitted for single events or instances of recurring
   * events.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_recurrence() {
    Json::Value* storage = MutableStorage("recurrence");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Determine if the '<code>recurringEventId</code>' attribute was set.
   *
   * @return true if the '<code>recurringEventId</code>' attribute was set.
   */
  bool has_recurring_event_id() const {
    return Storage().isMember("recurringEventId");
  }

  /**
   * Clears the '<code>recurringEventId</code>' attribute.
   */
  void clear_recurring_event_id() {
    MutableStorage()->removeMember("recurringEventId");
  }


  /**
   * Get the value of the '<code>recurringEventId</code>' attribute.
   */
  const StringPiece get_recurring_event_id() const {
    const Json::Value& v = Storage("recurringEventId");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>recurringEventId</code>' attribute.
   *
   * For an instance of a recurring event, this is the id of the recurring event
   * to which this instance belongs. Immutable.
   *
   * @param[in] value The new value.
   */
  void set_recurring_event_id(const StringPiece& value) {
    *MutableStorage("recurringEventId") = value.data();
  }

  /**
   * Determine if the '<code>reminders</code>' attribute was set.
   *
   * @return true if the '<code>reminders</code>' attribute was set.
   */
  bool has_reminders() const {
    return Storage().isMember("reminders");
  }

  /**
   * Clears the '<code>reminders</code>' attribute.
   */
  void clear_reminders() {
    MutableStorage()->removeMember("reminders");
  }


  /**
   * Get a reference to the value of the '<code>reminders</code>' attribute.
   */
  const EventReminders get_reminders() const {
     const Json::Value& storage = Storage("reminders");
    return client::JsonValueToCppValueHelper<EventReminders >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>reminders</code>'
   * property.
   *
   * Information about the event's reminders for the authenticated user.
   *
   * @return The result can be modified to change the attribute value.
   */
  EventReminders mutable_reminders() {
    Json::Value* storage = MutableStorage("reminders");
    return client::JsonValueToMutableCppValueHelper<EventReminders >(storage);
  }

  /**
   * Determine if the '<code>sequence</code>' attribute was set.
   *
   * @return true if the '<code>sequence</code>' attribute was set.
   */
  bool has_sequence() const {
    return Storage().isMember("sequence");
  }

  /**
   * Clears the '<code>sequence</code>' attribute.
   */
  void clear_sequence() {
    MutableStorage()->removeMember("sequence");
  }


  /**
   * Get the value of the '<code>sequence</code>' attribute.
   */
  int32 get_sequence() const {
    const Json::Value& storage = Storage("sequence");
    return client::JsonValueToCppValueHelper<int32 >(storage);
  }

  /**
   * Change the '<code>sequence</code>' attribute.
   *
   * Sequence number as per iCalendar.
   *
   * @param[in] value The new value.
   */
  void set_sequence(int32 value) {
    client::SetJsonValueFromCppValueHelper<int32 >(
      value, MutableStorage("sequence"));
  }

  /**
   * Determine if the '<code>source</code>' attribute was set.
   *
   * @return true if the '<code>source</code>' attribute was set.
   */
  bool has_source() const {
    return Storage().isMember("source");
  }

  /**
   * Clears the '<code>source</code>' attribute.
   */
  void clear_source() {
    MutableStorage()->removeMember("source");
  }


  /**
   * Get a reference to the value of the '<code>source</code>' attribute.
   */
  const EventSource get_source() const {
     const Json::Value& storage = Storage("source");
    return client::JsonValueToCppValueHelper<EventSource >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>source</code>' property.
   *
   * Source from which the event was created. For example, a web page, an email
   * message or any document identifiable by an URL with HTTP or HTTPS scheme.
   * Can only be seen or modified by the creator of the event.
   *
   * @return The result can be modified to change the attribute value.
   */
  EventSource mutable_source() {
    Json::Value* storage = MutableStorage("source");
    return client::JsonValueToMutableCppValueHelper<EventSource >(storage);
  }

  /**
   * Determine if the '<code>start</code>' attribute was set.
   *
   * @return true if the '<code>start</code>' attribute was set.
   */
  bool has_start() const {
    return Storage().isMember("start");
  }

  /**
   * Clears the '<code>start</code>' attribute.
   */
  void clear_start() {
    MutableStorage()->removeMember("start");
  }


  /**
   * Get a reference to the value of the '<code>start</code>' attribute.
   */
  const EventDateTime get_start() const;

  /**
   * Gets a reference to a mutable value of the '<code>start</code>' property.
   *
   * The (inclusive) start time of the event. For a recurring event, this is the
   * start time of the first instance.
   *
   * @return The result can be modified to change the attribute value.
   */
  EventDateTime mutable_start();

  /**
   * Determine if the '<code>status</code>' attribute was set.
   *
   * @return true if the '<code>status</code>' attribute was set.
   */
  bool has_status() const {
    return Storage().isMember("status");
  }

  /**
   * Clears the '<code>status</code>' attribute.
   */
  void clear_status() {
    MutableStorage()->removeMember("status");
  }


  /**
   * Get the value of the '<code>status</code>' attribute.
   */
  const StringPiece get_status() const {
    const Json::Value& v = Storage("status");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>status</code>' attribute.
   *
   * Status of the event. Optional. Possible values are:
   * <dl>
   * <dt>"confirmed"
   * <dd>The event is confirmed. This is the default status.
   * <dt>"tentative"
   * <dd>The event is tentatively confirmed.
   * <dt>"cancelled"
   * <dd>The event is cancelled.
   * </dl>
   *
   *
   * @param[in] value The new value.
   */
  void set_status(const StringPiece& value) {
    *MutableStorage("status") = value.data();
  }

  /**
   * Determine if the '<code>summary</code>' attribute was set.
   *
   * @return true if the '<code>summary</code>' attribute was set.
   */
  bool has_summary() const {
    return Storage().isMember("summary");
  }

  /**
   * Clears the '<code>summary</code>' attribute.
   */
  void clear_summary() {
    MutableStorage()->removeMember("summary");
  }


  /**
   * Get the value of the '<code>summary</code>' attribute.
   */
  const StringPiece get_summary() const {
    const Json::Value& v = Storage("summary");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>summary</code>' attribute.
   *
   * Title of the event.
   *
   * @param[in] value The new value.
   */
  void set_summary(const StringPiece& value) {
    *MutableStorage("summary") = value.data();
  }

  /**
   * Determine if the '<code>transparency</code>' attribute was set.
   *
   * @return true if the '<code>transparency</code>' attribute was set.
   */
  bool has_transparency() const {
    return Storage().isMember("transparency");
  }

  /**
   * Clears the '<code>transparency</code>' attribute.
   */
  void clear_transparency() {
    MutableStorage()->removeMember("transparency");
  }


  /**
   * Get the value of the '<code>transparency</code>' attribute.
   */
  const StringPiece get_transparency() const {
    const Json::Value& v = Storage("transparency");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>transparency</code>' attribute.
   *
   * Whether the event blocks time on the calendar. Optional. Possible values
   * are:
   * <dl>
   * <dt>"opaque"
   * <dd>Default value. The event does block time on the calendar. This is
   * equivalent to setting Show me as to Busy in the Calendar UI.
   * <dt>"transparent"
   * <dd>The event does not block time on the calendar. This is equivalent to
   * setting Show me as to Available in the Calendar UI.
   * </dl>
   *
   *
   * @param[in] value The new value.
   */
  void set_transparency(const StringPiece& value) {
    *MutableStorage("transparency") = value.data();
  }

  /**
   * Determine if the '<code>updated</code>' attribute was set.
   *
   * @return true if the '<code>updated</code>' attribute was set.
   */
  bool has_updated() const {
    return Storage().isMember("updated");
  }

  /**
   * Clears the '<code>updated</code>' attribute.
   */
  void clear_updated() {
    MutableStorage()->removeMember("updated");
  }


  /**
   * Get the value of the '<code>updated</code>' attribute.
   */
  client::DateTime get_updated() const {
    const Json::Value& storage = Storage("updated");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>updated</code>' attribute.
   *
   * Last modification time of the event (as a RFC3339 timestamp). Read-only.
   *
   * @param[in] value The new value.
   */
  void set_updated(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("updated"));
  }

  /**
   * Determine if the '<code>visibility</code>' attribute was set.
   *
   * @return true if the '<code>visibility</code>' attribute was set.
   */
  bool has_visibility() const {
    return Storage().isMember("visibility");
  }

  /**
   * Clears the '<code>visibility</code>' attribute.
   */
  void clear_visibility() {
    MutableStorage()->removeMember("visibility");
  }


  /**
   * Get the value of the '<code>visibility</code>' attribute.
   */
  const StringPiece get_visibility() const {
    const Json::Value& v = Storage("visibility");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>visibility</code>' attribute.
   *
   * Visibility of the event. Optional. Possible values are:
   * <dl>
   * <dt>"default"
   * <dd>Uses the default visibility for events on the calendar. This is the
   * default value.
   * <dt>"public"
   * <dd>The event is public and event details are visible to all readers of the
   * calendar.
   * <dt>"private"
   * <dd>The event is private and only event attendees may view event details.
   * <dt>"confidential"
   * <dd>The event is private. This value is provided for compatibility reasons.
   * </dl>
   *
   *
   * @param[in] value The new value.
   */
  void set_visibility(const StringPiece& value) {
    *MutableStorage("visibility") = value.data();
  }

 private:
  void operator=(const Event&);
};  // Event
}  // namespace google_calendar_api
#endif  // GOOGLE_CALENDAR_API_EVENT_H_
