// Copyright 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// This code was generated by google-apis-code-generator 1.5.0
//   Build date: 2014-11-17 18:43:33 UTC
//   on: 2014-12-12, 14:51:57 UTC
//   C++ generator version:

// ----------------------------------------------------------------------------
// NOTE: This file is generated from Google APIs Discovery Service.
// Service:
//   Drive API (drive/v2)
// Generated from:
//   Version: v2
//   Revision: 155
// Generated by:
//    Tool: google-apis-code-generator 1.5.0
//     C++: 0.1.2
#ifndef  GOOGLE_DRIVE_API_APP_H_
#define  GOOGLE_DRIVE_API_APP_H_

#include <string>
#include "googleapis/base/integral_types.h"
#include "googleapis/base/macros.h"
#include "googleapis/client/data/jsoncpp_data.h"
#include "googleapis/strings/stringpiece.h"

namespace Json {
class Value;
}  // namespace Json

namespace google_drive_api {
using namespace googleapis;

/**
 * The apps resource provides a list of the apps that a user has installed, with
 * information about each app's supported MIME types, file extensions, and other
 * details.
 *
 * @ingroup DataObject
 */
class App : public client::JsonCppData {
 public:

  /**
   * No description provided.
   *
   * @ingroup DataObject
   */
  class AppIcons : public client::JsonCppData {
   public:

    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static AppIcons* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit AppIcons(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit AppIcons(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~AppIcons();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::AppIcons</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::AppIcons");
    }

    /**
     * Determine if the '<code>category</code>' attribute was set.
     *
     * @return true if the '<code>category</code>' attribute was set.
     */
    bool has_category() const {
      return Storage().isMember("category");
    }

    /**
     * Clears the '<code>category</code>' attribute.
     */
    void clear_category() {
      MutableStorage()->removeMember("category");
    }


    /**
     * Get the value of the '<code>category</code>' attribute.
     */
    const StringPiece get_category() const {
      const Json::Value& v = Storage("category");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>category</code>' attribute.
     *
     * Category of the icon. Allowed values are:
     * <dl>
     * <dt>application
     * <dd>icon for the application.
     * <dt>document
     * <dd>icon for a file associated with the app.
     * <dt>documentShared
     * <dd>icon for a shared file associated with the app.
     * </dl>
     *
     *
     * @param[in] value The new value.
     */
    void set_category(const StringPiece& value) {
      *MutableStorage("category") = value.data();
    }

    /**
     * Determine if the '<code>iconUrl</code>' attribute was set.
     *
     * @return true if the '<code>iconUrl</code>' attribute was set.
     */
    bool has_icon_url() const {
      return Storage().isMember("iconUrl");
    }

    /**
     * Clears the '<code>iconUrl</code>' attribute.
     */
    void clear_icon_url() {
      MutableStorage()->removeMember("iconUrl");
    }


    /**
     * Get the value of the '<code>iconUrl</code>' attribute.
     */
    const StringPiece get_icon_url() const {
      const Json::Value& v = Storage("iconUrl");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>iconUrl</code>' attribute.
     *
     * URL for the icon.
     *
     * @param[in] value The new value.
     */
    void set_icon_url(const StringPiece& value) {
      *MutableStorage("iconUrl") = value.data();
    }

    /**
     * Determine if the '<code>size</code>' attribute was set.
     *
     * @return true if the '<code>size</code>' attribute was set.
     */
    bool has_size() const {
      return Storage().isMember("size");
    }

    /**
     * Clears the '<code>size</code>' attribute.
     */
    void clear_size() {
      MutableStorage()->removeMember("size");
    }


    /**
     * Get the value of the '<code>size</code>' attribute.
     */
    int32 get_size() const {
      const Json::Value& storage = Storage("size");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>size</code>' attribute.
     *
     * Size of the icon. Represented as the maximum of the width and height.
     *
     * @param[in] value The new value.
     */
    void set_size(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("size"));
    }

   private:
    void operator=(const AppIcons&);
  };  // AppIcons
  /**
   * Creates a new default instance.
   *
   * @return Ownership is passed back to the caller.
   */
  static App* New();

  /**
   * Standard constructor for an immutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit App(const Json::Value& storage);

  /**
   * Standard constructor for a mutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit App(Json::Value* storage);

  /**
   * Standard destructor.
   */
  virtual ~App();

  /**
   * Returns a string denoting the type of this data object.
   *
   * @return <code>google_drive_api::App</code>
   */
  const StringPiece GetTypeName() const {
    return StringPiece("google_drive_api::App");
  }

  /**
   * Determine if the '<code>authorized</code>' attribute was set.
   *
   * @return true if the '<code>authorized</code>' attribute was set.
   */
  bool has_authorized() const {
    return Storage().isMember("authorized");
  }

  /**
   * Clears the '<code>authorized</code>' attribute.
   */
  void clear_authorized() {
    MutableStorage()->removeMember("authorized");
  }


  /**
   * Get the value of the '<code>authorized</code>' attribute.
   */
  bool get_authorized() const {
    const Json::Value& storage = Storage("authorized");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>authorized</code>' attribute.
   *
   * Whether the app is authorized to access data on the user's Drive.
   *
   * @param[in] value The new value.
   */
  void set_authorized(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("authorized"));
  }

  /**
   * Determine if the '<code>createInFolderTemplate</code>' attribute was set.
   *
   * @return true if the '<code>createInFolderTemplate</code>' attribute was
   * set.
   */
  bool has_create_in_folder_template() const {
    return Storage().isMember("createInFolderTemplate");
  }

  /**
   * Clears the '<code>createInFolderTemplate</code>' attribute.
   */
  void clear_create_in_folder_template() {
    MutableStorage()->removeMember("createInFolderTemplate");
  }


  /**
   * Get the value of the '<code>createInFolderTemplate</code>' attribute.
   */
  const StringPiece get_create_in_folder_template() const {
    const Json::Value& v = Storage("createInFolderTemplate");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>createInFolderTemplate</code>' attribute.
   *
   * The template url to create a new file with this app in a given folder. The
   * template will contain {folderId} to be replaced by the folder to create the
   * new file in.
   *
   * @param[in] value The new value.
   */
  void set_create_in_folder_template(const StringPiece& value) {
    *MutableStorage("createInFolderTemplate") = value.data();
  }

  /**
   * Determine if the '<code>createUrl</code>' attribute was set.
   *
   * @return true if the '<code>createUrl</code>' attribute was set.
   */
  bool has_create_url() const {
    return Storage().isMember("createUrl");
  }

  /**
   * Clears the '<code>createUrl</code>' attribute.
   */
  void clear_create_url() {
    MutableStorage()->removeMember("createUrl");
  }


  /**
   * Get the value of the '<code>createUrl</code>' attribute.
   */
  const StringPiece get_create_url() const {
    const Json::Value& v = Storage("createUrl");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>createUrl</code>' attribute.
   *
   * The url to create a new file with this app.
   *
   * @param[in] value The new value.
   */
  void set_create_url(const StringPiece& value) {
    *MutableStorage("createUrl") = value.data();
  }

  /**
   * Determine if the '<code>hasDriveWideScope</code>' attribute was set.
   *
   * @return true if the '<code>hasDriveWideScope</code>' attribute was set.
   */
  bool has_has_drive_wide_scope() const {
    return Storage().isMember("hasDriveWideScope");
  }

  /**
   * Clears the '<code>hasDriveWideScope</code>' attribute.
   */
  void clear_has_drive_wide_scope() {
    MutableStorage()->removeMember("hasDriveWideScope");
  }


  /**
   * Get the value of the '<code>hasDriveWideScope</code>' attribute.
   */
  bool get_has_drive_wide_scope() const {
    const Json::Value& storage = Storage("hasDriveWideScope");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>hasDriveWideScope</code>' attribute.
   *
   * Whether the app has drive-wide scope. An app with drive-wide scope can
   * access all files in the user's drive.
   *
   * @param[in] value The new value.
   */
  void set_has_drive_wide_scope(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("hasDriveWideScope"));
  }

  /**
   * Determine if the '<code>icons</code>' attribute was set.
   *
   * @return true if the '<code>icons</code>' attribute was set.
   */
  bool has_icons() const {
    return Storage().isMember("icons");
  }

  /**
   * Clears the '<code>icons</code>' attribute.
   */
  void clear_icons() {
    MutableStorage()->removeMember("icons");
  }


  /**
   * Get a reference to the value of the '<code>icons</code>' attribute.
   */
  const client::JsonCppArray<AppIcons > get_icons() const {
     const Json::Value& storage = Storage("icons");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<AppIcons > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>icons</code>' property.
   *
   * The various icons for the app.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<AppIcons > mutable_icons() {
    Json::Value* storage = MutableStorage("icons");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<AppIcons > >(storage);
  }

  /**
   * Determine if the '<code>id</code>' attribute was set.
   *
   * @return true if the '<code>id</code>' attribute was set.
   */
  bool has_id() const {
    return Storage().isMember("id");
  }

  /**
   * Clears the '<code>id</code>' attribute.
   */
  void clear_id() {
    MutableStorage()->removeMember("id");
  }


  /**
   * Get the value of the '<code>id</code>' attribute.
   */
  const StringPiece get_id() const {
    const Json::Value& v = Storage("id");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>id</code>' attribute.
   *
   * The ID of the app.
   *
   * @param[in] value The new value.
   */
  void set_id(const StringPiece& value) {
    *MutableStorage("id") = value.data();
  }

  /**
   * Determine if the '<code>installed</code>' attribute was set.
   *
   * @return true if the '<code>installed</code>' attribute was set.
   */
  bool has_installed() const {
    return Storage().isMember("installed");
  }

  /**
   * Clears the '<code>installed</code>' attribute.
   */
  void clear_installed() {
    MutableStorage()->removeMember("installed");
  }


  /**
   * Get the value of the '<code>installed</code>' attribute.
   */
  bool get_installed() const {
    const Json::Value& storage = Storage("installed");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>installed</code>' attribute.
   *
   * Whether the app is installed.
   *
   * @param[in] value The new value.
   */
  void set_installed(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("installed"));
  }

  /**
   * Determine if the '<code>kind</code>' attribute was set.
   *
   * @return true if the '<code>kind</code>' attribute was set.
   */
  bool has_kind() const {
    return Storage().isMember("kind");
  }

  /**
   * Clears the '<code>kind</code>' attribute.
   */
  void clear_kind() {
    MutableStorage()->removeMember("kind");
  }


  /**
   * Get the value of the '<code>kind</code>' attribute.
   */
  const StringPiece get_kind() const {
    const Json::Value& v = Storage("kind");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>kind</code>' attribute.
   *
   * This is always drive#app.
   *
   * @param[in] value The new value.
   */
  void set_kind(const StringPiece& value) {
    *MutableStorage("kind") = value.data();
  }

  /**
   * Determine if the '<code>longDescription</code>' attribute was set.
   *
   * @return true if the '<code>longDescription</code>' attribute was set.
   */
  bool has_long_description() const {
    return Storage().isMember("longDescription");
  }

  /**
   * Clears the '<code>longDescription</code>' attribute.
   */
  void clear_long_description() {
    MutableStorage()->removeMember("longDescription");
  }


  /**
   * Get the value of the '<code>longDescription</code>' attribute.
   */
  const StringPiece get_long_description() const {
    const Json::Value& v = Storage("longDescription");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>longDescription</code>' attribute.
   *
   * A long description of the app.
   *
   * @param[in] value The new value.
   */
  void set_long_description(const StringPiece& value) {
    *MutableStorage("longDescription") = value.data();
  }

  /**
   * Determine if the '<code>name</code>' attribute was set.
   *
   * @return true if the '<code>name</code>' attribute was set.
   */
  bool has_name() const {
    return Storage().isMember("name");
  }

  /**
   * Clears the '<code>name</code>' attribute.
   */
  void clear_name() {
    MutableStorage()->removeMember("name");
  }


  /**
   * Get the value of the '<code>name</code>' attribute.
   */
  const StringPiece get_name() const {
    const Json::Value& v = Storage("name");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>name</code>' attribute.
   *
   * The name of the app.
   *
   * @param[in] value The new value.
   */
  void set_name(const StringPiece& value) {
    *MutableStorage("name") = value.data();
  }

  /**
   * Determine if the '<code>objectType</code>' attribute was set.
   *
   * @return true if the '<code>objectType</code>' attribute was set.
   */
  bool has_object_type() const {
    return Storage().isMember("objectType");
  }

  /**
   * Clears the '<code>objectType</code>' attribute.
   */
  void clear_object_type() {
    MutableStorage()->removeMember("objectType");
  }


  /**
   * Get the value of the '<code>objectType</code>' attribute.
   */
  const StringPiece get_object_type() const {
    const Json::Value& v = Storage("objectType");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>objectType</code>' attribute.
   *
   * The type of object this app creates (e.g. Chart). If empty, the app name
   * should be used instead.
   *
   * @param[in] value The new value.
   */
  void set_object_type(const StringPiece& value) {
    *MutableStorage("objectType") = value.data();
  }

  /**
   * Determine if the '<code>openUrlTemplate</code>' attribute was set.
   *
   * @return true if the '<code>openUrlTemplate</code>' attribute was set.
   */
  bool has_open_url_template() const {
    return Storage().isMember("openUrlTemplate");
  }

  /**
   * Clears the '<code>openUrlTemplate</code>' attribute.
   */
  void clear_open_url_template() {
    MutableStorage()->removeMember("openUrlTemplate");
  }


  /**
   * Get the value of the '<code>openUrlTemplate</code>' attribute.
   */
  const StringPiece get_open_url_template() const {
    const Json::Value& v = Storage("openUrlTemplate");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>openUrlTemplate</code>' attribute.
   *
   * The template url for opening files with this app. The template will contain
   * {ids} and/or {exportIds} to be replaced by the actual file ids.
   *
   * @param[in] value The new value.
   */
  void set_open_url_template(const StringPiece& value) {
    *MutableStorage("openUrlTemplate") = value.data();
  }

  /**
   * Determine if the '<code>primaryFileExtensions</code>' attribute was set.
   *
   * @return true if the '<code>primaryFileExtensions</code>' attribute was set.
   */
  bool has_primary_file_extensions() const {
    return Storage().isMember("primaryFileExtensions");
  }

  /**
   * Clears the '<code>primaryFileExtensions</code>' attribute.
   */
  void clear_primary_file_extensions() {
    MutableStorage()->removeMember("primaryFileExtensions");
  }


  /**
   * Get a reference to the value of the '<code>primaryFileExtensions</code>'
   * attribute.
   */
  const client::JsonCppArray<string > get_primary_file_extensions() const {
     const Json::Value& storage = Storage("primaryFileExtensions");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the
   * '<code>primaryFileExtensions</code>' property.
   *
   * The list of primary file extensions.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_primaryFileExtensions() {
    Json::Value* storage = MutableStorage("primaryFileExtensions");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Determine if the '<code>primaryMimeTypes</code>' attribute was set.
   *
   * @return true if the '<code>primaryMimeTypes</code>' attribute was set.
   */
  bool has_primary_mime_types() const {
    return Storage().isMember("primaryMimeTypes");
  }

  /**
   * Clears the '<code>primaryMimeTypes</code>' attribute.
   */
  void clear_primary_mime_types() {
    MutableStorage()->removeMember("primaryMimeTypes");
  }


  /**
   * Get a reference to the value of the '<code>primaryMimeTypes</code>'
   * attribute.
   */
  const client::JsonCppArray<string > get_primary_mime_types() const {
     const Json::Value& storage = Storage("primaryMimeTypes");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>primaryMimeTypes</code>'
   * property.
   *
   * The list of primary mime types.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_primaryMimeTypes() {
    Json::Value* storage = MutableStorage("primaryMimeTypes");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Determine if the '<code>productId</code>' attribute was set.
   *
   * @return true if the '<code>productId</code>' attribute was set.
   */
  bool has_product_id() const {
    return Storage().isMember("productId");
  }

  /**
   * Clears the '<code>productId</code>' attribute.
   */
  void clear_product_id() {
    MutableStorage()->removeMember("productId");
  }


  /**
   * Get the value of the '<code>productId</code>' attribute.
   */
  const StringPiece get_product_id() const {
    const Json::Value& v = Storage("productId");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>productId</code>' attribute.
   *
   * The ID of the product listing for this app.
   *
   * @param[in] value The new value.
   */
  void set_product_id(const StringPiece& value) {
    *MutableStorage("productId") = value.data();
  }

  /**
   * Determine if the '<code>productUrl</code>' attribute was set.
   *
   * @return true if the '<code>productUrl</code>' attribute was set.
   */
  bool has_product_url() const {
    return Storage().isMember("productUrl");
  }

  /**
   * Clears the '<code>productUrl</code>' attribute.
   */
  void clear_product_url() {
    MutableStorage()->removeMember("productUrl");
  }


  /**
   * Get the value of the '<code>productUrl</code>' attribute.
   */
  const StringPiece get_product_url() const {
    const Json::Value& v = Storage("productUrl");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>productUrl</code>' attribute.
   *
   * A link to the product listing for this app.
   *
   * @param[in] value The new value.
   */
  void set_product_url(const StringPiece& value) {
    *MutableStorage("productUrl") = value.data();
  }

  /**
   * Determine if the '<code>secondaryFileExtensions</code>' attribute was set.
   *
   * @return true if the '<code>secondaryFileExtensions</code>' attribute was
   * set.
   */
  bool has_secondary_file_extensions() const {
    return Storage().isMember("secondaryFileExtensions");
  }

  /**
   * Clears the '<code>secondaryFileExtensions</code>' attribute.
   */
  void clear_secondary_file_extensions() {
    MutableStorage()->removeMember("secondaryFileExtensions");
  }


  /**
   * Get a reference to the value of the '<code>secondaryFileExtensions</code>'
   * attribute.
   */
  const client::JsonCppArray<string > get_secondary_file_extensions() const {
     const Json::Value& storage = Storage("secondaryFileExtensions");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the
   * '<code>secondaryFileExtensions</code>' property.
   *
   * The list of secondary file extensions.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_secondaryFileExtensions() {
    Json::Value* storage = MutableStorage("secondaryFileExtensions");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Determine if the '<code>secondaryMimeTypes</code>' attribute was set.
   *
   * @return true if the '<code>secondaryMimeTypes</code>' attribute was set.
   */
  bool has_secondary_mime_types() const {
    return Storage().isMember("secondaryMimeTypes");
  }

  /**
   * Clears the '<code>secondaryMimeTypes</code>' attribute.
   */
  void clear_secondary_mime_types() {
    MutableStorage()->removeMember("secondaryMimeTypes");
  }


  /**
   * Get a reference to the value of the '<code>secondaryMimeTypes</code>'
   * attribute.
   */
  const client::JsonCppArray<string > get_secondary_mime_types() const {
     const Json::Value& storage = Storage("secondaryMimeTypes");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the
   * '<code>secondaryMimeTypes</code>' property.
   *
   * The list of secondary mime types.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_secondaryMimeTypes() {
    Json::Value* storage = MutableStorage("secondaryMimeTypes");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Determine if the '<code>shortDescription</code>' attribute was set.
   *
   * @return true if the '<code>shortDescription</code>' attribute was set.
   */
  bool has_short_description() const {
    return Storage().isMember("shortDescription");
  }

  /**
   * Clears the '<code>shortDescription</code>' attribute.
   */
  void clear_short_description() {
    MutableStorage()->removeMember("shortDescription");
  }


  /**
   * Get the value of the '<code>shortDescription</code>' attribute.
   */
  const StringPiece get_short_description() const {
    const Json::Value& v = Storage("shortDescription");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>shortDescription</code>' attribute.
   *
   * A short description of the app.
   *
   * @param[in] value The new value.
   */
  void set_short_description(const StringPiece& value) {
    *MutableStorage("shortDescription") = value.data();
  }

  /**
   * Determine if the '<code>supportsCreate</code>' attribute was set.
   *
   * @return true if the '<code>supportsCreate</code>' attribute was set.
   */
  bool has_supports_create() const {
    return Storage().isMember("supportsCreate");
  }

  /**
   * Clears the '<code>supportsCreate</code>' attribute.
   */
  void clear_supports_create() {
    MutableStorage()->removeMember("supportsCreate");
  }


  /**
   * Get the value of the '<code>supportsCreate</code>' attribute.
   */
  bool get_supports_create() const {
    const Json::Value& storage = Storage("supportsCreate");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>supportsCreate</code>' attribute.
   *
   * Whether this app supports creating new objects.
   *
   * @param[in] value The new value.
   */
  void set_supports_create(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("supportsCreate"));
  }

  /**
   * Determine if the '<code>supportsImport</code>' attribute was set.
   *
   * @return true if the '<code>supportsImport</code>' attribute was set.
   */
  bool has_supports_import() const {
    return Storage().isMember("supportsImport");
  }

  /**
   * Clears the '<code>supportsImport</code>' attribute.
   */
  void clear_supports_import() {
    MutableStorage()->removeMember("supportsImport");
  }


  /**
   * Get the value of the '<code>supportsImport</code>' attribute.
   */
  bool get_supports_import() const {
    const Json::Value& storage = Storage("supportsImport");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>supportsImport</code>' attribute.
   *
   * Whether this app supports importing Google Docs.
   *
   * @param[in] value The new value.
   */
  void set_supports_import(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("supportsImport"));
  }

  /**
   * Determine if the '<code>supportsMultiOpen</code>' attribute was set.
   *
   * @return true if the '<code>supportsMultiOpen</code>' attribute was set.
   */
  bool has_supports_multi_open() const {
    return Storage().isMember("supportsMultiOpen");
  }

  /**
   * Clears the '<code>supportsMultiOpen</code>' attribute.
   */
  void clear_supports_multi_open() {
    MutableStorage()->removeMember("supportsMultiOpen");
  }


  /**
   * Get the value of the '<code>supportsMultiOpen</code>' attribute.
   */
  bool get_supports_multi_open() const {
    const Json::Value& storage = Storage("supportsMultiOpen");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>supportsMultiOpen</code>' attribute.
   *
   * Whether this app supports opening more than one file.
   *
   * @param[in] value The new value.
   */
  void set_supports_multi_open(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("supportsMultiOpen"));
  }

  /**
   * Determine if the '<code>supportsOfflineCreate</code>' attribute was set.
   *
   * @return true if the '<code>supportsOfflineCreate</code>' attribute was set.
   */
  bool has_supports_offline_create() const {
    return Storage().isMember("supportsOfflineCreate");
  }

  /**
   * Clears the '<code>supportsOfflineCreate</code>' attribute.
   */
  void clear_supports_offline_create() {
    MutableStorage()->removeMember("supportsOfflineCreate");
  }


  /**
   * Get the value of the '<code>supportsOfflineCreate</code>' attribute.
   */
  bool get_supports_offline_create() const {
    const Json::Value& storage = Storage("supportsOfflineCreate");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>supportsOfflineCreate</code>' attribute.
   *
   * Whether this app supports creating new files when offline.
   *
   * @param[in] value The new value.
   */
  void set_supports_offline_create(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("supportsOfflineCreate"));
  }

  /**
   * Determine if the '<code>useByDefault</code>' attribute was set.
   *
   * @return true if the '<code>useByDefault</code>' attribute was set.
   */
  bool has_use_by_default() const {
    return Storage().isMember("useByDefault");
  }

  /**
   * Clears the '<code>useByDefault</code>' attribute.
   */
  void clear_use_by_default() {
    MutableStorage()->removeMember("useByDefault");
  }


  /**
   * Get the value of the '<code>useByDefault</code>' attribute.
   */
  bool get_use_by_default() const {
    const Json::Value& storage = Storage("useByDefault");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>useByDefault</code>' attribute.
   *
   * Whether the app is selected as the default handler for the types it
   * supports.
   *
   * @param[in] value The new value.
   */
  void set_use_by_default(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("useByDefault"));
  }

 private:
  void operator=(const App&);
};  // App
}  // namespace google_drive_api
#endif  // GOOGLE_DRIVE_API_APP_H_
